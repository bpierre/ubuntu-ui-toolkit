/*
 * Copyright 2012 Canonical Ltd.
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License version 3 as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*!
  \page theming-components.html
  \ingroup theming-description
  \title Theming Ubuntu Components

  \b{The theming is under heavy development therefore changes may occur frequiently,
  and may not be in sync with this documentation.}

  \section1 What is theming and why is needed?

  Theming is one of the most important aspects of a component set that is aimed
  to be fully reusable and customizable. There are various trials and solutions
  available that use different methods and approaches for what they consider
  theming. With proper theming support both the look and feel can be changed without
  altering the components API or implementation.

  \section1 Theming Engine, Theming Components

  The theming used in Ubuntu Components follows this idea of changing LAF (Look-And-Feel)
  Uses ideas from CSS stylesheets, however it does not provide yet another implementation
  of that. The framework supports themes defined in QML as well as in the so-called
  QmlTheme theme file format (.qmltheme). Theme files are loaded by the components
  library upon startup before any QML element of the application would be loaded.
  The library uses the settings to load and store user and application specific
  theming. User theme configuration is stored under \c{$HOME/.qmltheme/theme.ini}
  file, which contains the following setting keys:
  \list
   \li \b{theme} specifies the actual theme set for the user, more precisely the
   folder name of the theme stored under \c{/var/shared/themes} system folder.
   \li \b{imports} specifies the paths where the compoments used in the theme are
   located. Multiple folders can be added to the import path and those must be
   separated with column character. These paths are then added to Qml Engine when
   the theme file is loaded. This key is optional.
  \endlist

  Theme folders are stored under \c qmltheme, and the default theme file, which
  defines the theme is \c default.qml or \c default.qmltheme.

  For example \e Ambiance theme is located under \c{/var/shared/themes/Ambiance}
  and the default theme file therefore will be at \c{/var/shared/themes/Ambiance/qmltheme/default.qmltheme}.

  Themes can define application specific themes. These are stored under the system
  theme folder. These theme files are stored in application settings and also loaded
  upon startup. An application supporting theming must define the following setting
  keys:
  \list
   \li \b{UseSystemTheme} specifies whether the application uses the system theme
   or not.
   \li \b{ThemeFile} specifies the theme file to be loaded. If the application uses
   the system theme, the field defines the relative path to the system theme folder.
   If the system theme is not used (private theme), the path can either be a full
   path to the theme, relative to the current directory or a resource.
   \li \b{imports} same as in theme's case, contains the folders to be added to the
   import aths of the QML engine. The presence of this key is needed when themes are
   defined in QML format.
  \endlist

  Using the example above, assuming the application uses the system themes, and
  application's theme is "someapp.qmltheme", the theme file full path will be
  \c{/var/shared/themes/Ambiance/qmltheme/someapp.qmltheme}.

  When themes are loaded, the engine builds up a map of \l{Rule} elements to ease
  style lookup. These style rules are applied only on items, which have styling
  defined using \l ItemStyle attached properties. ItemStyle attached object will
  look after style rules based on the styling information set and based on the
  hierarchy they are nested in. Style rules can define configuration properties
  (style property), visuals (delegate property) or both.

  Style rules are identified through \l{Rule::selector}{selectors}. Selectors follow
  the syntax defined in W3C, however does not provide full support for defined. This
  syntax is used in both QML- and QmlTheme file formats.
  The supported syntax is:
  \list
   \li - element name is either the style class defined on the QML element or the
   meta class name, therefore selectors are case sensitive
   \li - element names are always prefixed with a ‘.’ character
   \li - ID is the name of the widget prefixed with ‘#’ character
   \li - hierarchy on a style rule is represented
   \list
    \li * either with a space character in between selectors (e.g. “.Toolbar
        .Button”), when the style should be applied only if the widget occurs
        inside a particular widget
    \li * or with a ‘>’ character between selectors (“.Toolbar > .Button”), which
        is a restriction of the previous case, when a direct child relationship is
        mandated in the widget hierarchy
   \endlist
   \li - multiple selectors can share the same declaration block, by separating
   them with comma character
  \endlist

  \section2 QML theme files
  QML theme file consists of a document enumerating \l{Rule}{styling rules}.
  Each rule defines a particular style identified by a \l{Rule::selector}
  {selector}. The theme file is loaded using the QML engine and styles defined
  are stored in a suffix-tree to ease style lookup.

  \section2 QmlTheme file format
  The QmlTheme file format uses the ideas and format of CSS stylesheets, however does
  not implement teh full specification. QmlTheme files are identified through their
  extension, which is \e .qmltheme. A theme file can contain styling rules and
  so-called @-rules.

  \section3 @-rules
  @-rules are special rules, usually defined in one line ending with a semicolon
  character, and define further actions or primitives. QmlTheme defines the following
  @-rules:
  \list
   \li \b{@import url}
   \li \b{@qml-import}
   \li \b{@qml-mapping}
  \endlist

  \section4 @import rule
  Syntax:
    \code @import url(<url>);\endcode

  The rule instructs the theme engine to import an other QmlTheme file from a given
  location. The location can be relative to the current theme's folder, from an
  absolute path or from the resources.

  Examples:
  \list
   \li \code @import url("/var/shared/theme/Ambiance/qmltheme/sometheme.qmltheme");\endcode
   will import a theme from the given absolute path.
   \li \code@import url("foo/theme.qmltheme");\endcode will import a theme relative
   to the current path located under \c foo folder.
   \li \code@import url(qrc:/theme.qmltheme);\endcode will import the theme stored
   in the application resources. Note that aliases defined for the resources must
   contain the extension so the theming engine can identify the file type.
  \endlist

  \section4 @qml-import() rule
  Syntax: \code@qml-import (<import-module>[,<import-path>]);\endcode

  The rule instructs the theming engine to use the \c import-module when
  creating the styling components (styles and delegates). The \c import-path
  is an optional parameter, which when specified will be added to the QML engine's
  import path list. Therefore the parameter should be specified when the imported
  module specified in \c import-module is not included in the QML Engine's import
  path.

  The engine defines three tags that can be used in \c import-path syntax. These are
  the following:
  \list
   \li \b current: specifies the current folder from where the application was launched.
   \li \b application: specifies the application's executable folder
   \li \b system: specifies the system themes folder \c{"/var/shared/themes"}
  \endlist

  Examples:
  \list
  \li \code@qml-import(some.module 1.0);\endcode will add \c{some.module} to every QML
  component generated by the theme styling rules. The module is assumed to be
  located relative to the theme file including the statement.
  \li \code@qml-import(some.module 1.0, current:/foo);\endcode will add \c{some.module}
  to every QML component generated by the theme styling rules, and will add the
  \c foo folder that is located relative to the current folder.
  \endlist

  \section4 @qml-mapping() rule
  Syntax: \code@qml-mapping(<selector>,[<Style-element>],[<Delegate-element>]);\endcode

  The rule defines the style configuration and delegate elements for a given
  \c selector, which will be used when generating Rule elements. One of the
  \c Style-element and \c Delegate-element parameters must be specified. If one
  is left out, an empty value must be specified.

  Example:
  \list
   \li \code@qml-mapping(.button, ButtonStyle, ButtonDelegate);\endcode maps \c .button
   selector to use \c ButtonStyle element for styling and \c ButtonDelegate for
   visuals.
   \li \code@qml-mapping(.frame .button, OtherStyle, );\endcode maps "\c{.frame .button}"
   selector to use \c OtherStyle styling. As no delegate element is given, the
   system will use the visuals defined for the \c .button selector.
  \endlist

  \section2 The url() macro
  Resources may be stored in locations that are not resolvable using Qt.resolvedUrl()
  and those can be located relative to the current theme file. For example a theme
  may have all its resources stored in a subfolder near by the theme definition file.
  This URL cannot be resolved by the Qt.resolvedUrl() function as that one resolves
  paths that are relative to application's current path. In these cases themes can
  use the \b{url()} macro, which will resolve the given path relative to the current
  theme file parsed.

  Modifying the previous example having resources under a subfolder of the theme
  named "resources". The declaration block of the button would look as follows:
  \code
  .button {
    color: "lightgray";
    frame: url("resources/button-frame.png");
    pressedColor: Qt.darker(color, 1.2);
  }
  \endcode
  Assuming the theme is called "Foo", the generated QML Rule would look like
  \qml
  Rule {
      selector: ".button"
      style: ButtonStyle {
          color: "lightgray"
          frame: "/var/shared/themes/Foo/qmltheme/resources/button-frame.png"
          pressedColor: Qt.darker(color, 1.2)
      }
      delegate: Component {
          ButtonDelegate{}
      }
  }
  \endqml

  \section2 Style rules
  Style rules are defined using "selectors {declaration-block}" syntax, where
  selectors define one or more selectors separated with commas, and the declaration
  block following QML syntax to ease transfering of those to QML. Every line in the
  declaration block must be separated with semicolon character.

  The following example defines styling for a Button element identified with ".button"
  \code
  .button {
    color: "lightgray";
    frame: Qt.resolvedUrl("resources/button-frame.png");
    pressedColor: Qt.darker(color, 1.2);
  }
  \endcode

  Assuming the theme defines a mapping for the style called \c ButtonStyle and a
  delegate called \c ButtonDelegate, the generated Rule will look
  as follows:
  \qml
  Rule {
      selector: ".button"
      style: ButtonStyle {
          color: "lightgray"
          frame: Qt.resolvedUrl("resources/button-frame.png")
          pressedColor: Qt.darker(color, 1.2)
      }
      delegate: Component {
          ButtonDelegate{}
      }
  }
  \endqml
  In case the theme does not define maping for the selector, the generated Rule
  will look like
  \qml
  Rule {
      selector: ".button"
      style: QtObject {
          property var color: "lightgray"
          property var frame: Qt.resolvedUrl("resources/button-frame.png")
          property var pressedColor: Qt.darker(color, 1.2)
      }
  }
  \endqml

  The theming engine defines two properties that can be used to access the widget
  and the styling properties. These properties can be accessed then from the visuals
  defined. These context properties are:
  \list
    \li \b{widget} is defined to access widget properties
    \li \b{itemStyle} holds styling properties, and it is defined only if the widget
    uses delegates (visuals), therefore accessible within delegates
  \endlist

  For example, assume the Button widget is defined as follows:
  \qml
  Item {
      property bool hovered
      property bool pressed
  }
  \endqml
  where \a hovered specifies the hovered state and \a pressed the pressed state. The
  previous style could be modified to change the button color to lightgreen when hovered
  as follows:
  \code
  .button {
    color: widget.hovered ? "lightgreen" : "lightgray";
    frame: Qt.resolvedUrl("resources/button-frame.png");
    pressedColor: Qt.darker(color, 1.2);
  }
  \endcode

  \section1 Styling Widgets
  Styling elements is realised using attached properties grouped in ItemStyle
  element. The component can be attached to any element that supports visuals
  (i.e. derived from Item or QQuickItem), in this way it is possible to style
  existing QML elements, as well as component library widgets.

  The main properties that define styling are the \l{ItemStyle::class}{class} and
  \l{ItemStyle::name}{name} proeprties. \c class property
  declares the style class to be applied, and \c name defines the unique
  identifier of the widget. Theming engine uses these properties to build up
  the selector node that identifies the widget. The format used to build it is
  \c{.<class>[#<name>]}. If neither of these are specifies, but the
  widget still uses styling, the engine will look after the default style class,
  by substituting class to the meta class name (i.e. Button.qml this will be
  \c Button).

  Updating the previous example, the complete Button widget with style information
  would look like
  \qml
  Item {
      property bool hovered
      property bool pressed
      ItemStyle.class: "button"
  }
  \endqml

  When a widget style is located, the engine will build up the complete selector
  using the widget and its parents, considering only those parents that are styled
  for chosing the relation between them. The following example illustrates two
  situations for descendant and direct child compositors:
  \qml
  Toolbar {
      ItemStyle.class: "toolbar"
      Button {
          ItemStyle.class: "button"
      }
  }
  \endqml
  In this sample, the button will be styled using the rules defined for \a{".toolbar >
  .button"} or if not defined, according to the rules defined by \a ".button" selector.
  However, the following example will create a selector like \a{".toolbar .button"}
  as there is a non-styled element between Toolbar and Button, so Button is no
  longer a dirrect child of Toolbar.
  \qml
  Toolbar {
      ItemStyle.class: "toolbar"
      Row {
          Button {
              ItemStyle.class: "button"
          }
      }
  }
  \endqml

  \section1 Styling QML elements
  As mentioned before, attaching ItemStyle property to QML elements can also be used
  to style them. The following example styles a Text element. There's no delegate as
  the Text element provides the visuals needed to reate a Label widget.
  \code
  .label {
      fontSize: 12;
      color: "darkgray";
  }
  .red-label {
      fontSize: 12;
      color: "red";
  }
  \endcode

  \qml
  // Label.qml
  Text {
      ItemStyle.onStyleChanged: {
          if (ItemStyle.style && ItemStyle.style.fontSize)
              font.pixelSize = Qt.binding(function() {return ItemStyle.style.fontSize})
          if (ItemStyle.style && ItemStyle.style.color)
              color = Qt.binding(function() {return ItemStyle.style.color})
      }
  }
  \endqml
  When using the component, different styles can be applied as the following code sample
  illustrate:
  \code
  //dark gray colored text
  Label {
      ItemStyle.class: "label"
  }

  // red colored text
  Label {
      ItemStyle.class: "red-label"
  }
  \endcode

  \section1 Custom (private) Styles
  ItemStyles has two more properties, which hold the style configuration properties
  and the visuals. These properties are set the theme contains styling identified by
  the selector of the widget. These properties can also be set with styling configuration
  or delegates others than the ones defined in themes.

  An example of a Label that uses a private style configuration defining font
  size to be always 14 pixels and color as blue, would look like:
  \qml
  Label {
      ItemStyle.style: QtObject {
          property real fontSize: 14
          property color color: "blue"
      }
  }
  \endqml

  A particular widget user can decide to use private styles and delegates, style or
  delegate from theme and other one as private it or both from theme.
  A button that uses a private delegate but style from theme would look like
  \qml
  Button {
      id: button
      ItemStyle.class: "button"
      ItemStyle.delegate: Rectangle {
          anchors.fill: parent
          color: button.pressed ? button.ItemStyle.style.pressedColor : button.ItemStyle.style.color
          radius: 15
      }
  }
  \endqml

  \section1 QmlTheme theme file example
  Finally, here are some examples of QmlTheme themes.

  default.qmltheme
  \code
  @qml-mapping(.button, ButtonStyle, ButtonDelegate);
  @qml-mapping(.Button, ButtonStyle, ButtonDelegate);
  @qml-import(Ubuntu.Components 0.1);

    .Button, .button {
        color: "#e3e5e8";
        shapeDark: url("artwork/ButtonShapeDark.png");
        shapeNormal: url("artwork/ButtonShape.png");
        borderIdle: url("artwork/ButtonBorderIdle.png");
        borderPressed: url("artwork/ButtonBorderPressed.png");
        borderPressed: url("artwork/ButtonBorderPressed.png");
        borderDarkIdle: url("artwork/ButtonBorderDarkIdle.png");
        borderDarkPressed: url("artwork/ButtonBorderDarkPressed.png");
    }

    .label {
        fontFamily: "Ubuntu";
        fontSize: "medium";
        color: "red";
    }
  \endcode

  theme.qmltheme
  \code
  @import url("../default.qmltheme");
  @qml-import(themes 1.0, current:/demos);
  @qml-mapping(.frame, , TestFrameDelegate);

    .Button {
        color: widget.hovered ? "tan" : "lightgray";
    }

    .button {
        color: widget.hovered ? "lightgray" : "#a3e5e8";
    }

    .frame {
        color: "tan";
    }
  \endcode

  \section1 QML elements supporting theming
  Available through:
  \code
      import Ubuntu.Components 0.1
  \endcode
  \annotatedlist theming
*/
