/*
 * Copyright 2015 Canonical Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*!
 * \page ubuntu-theming.html
 * \title Styling - Introduction
 * \nextpage Component styles, Style API
 *
 * A style defines the visuals of a component. With some exceptions all UI Toolkit
 * components have styles declared. Some styles provide additional logic to the
 * component. These components rely on a well defined API, which must be implemented
 * by the styles. These APIs are provided by the Ubuntu.Components.Styles module.
 * One additional functionality of the style is to provide the implicit size of the
 * component. The theming engine applies the implicit size provided by the style
 * on the component, which can be overruled by the component.
 *
 * With some exceptions, each component's style document name is compound of the
 * component name plus the Style word. In this way the Button component's style is
 * ButtonStyle. These styles are grouped in themes. In addition to styles, themes
 * can also provide custom palette values. There are two themes in Ubuntu, Ambiance
 * and SuruDark themes, Ambiance being the default theme. Both themes are declared
 * in separate modules, in \c Ubuntu.Components.Themes.Ambiance ans well as
 * \c Ubuntu.Components.Themes.SuruDark. Application should define the theme name
 * using this dotted name format.
 *
 * Applications can decide which theme they want to use or they can provide their
 * own themes. Also, applications can use multiple themes or set custom palette values.
 *
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.3
 *
 * MainView {
 *     width: units,gu(40)
 *     height: units.gu(71)
 *
 *     theme.name: "Ubuntu.Components.Themes.SuruDark"
 * }
 * \endqml
 */

/*!
 * \page ubuntu-theming-styles.html
 * \title Component styles, Style API
 * \nextpage Themes, theme types, theme structure
 *
 * \section2 Naming conventions
 * With few exception, each toolkit component is having StyledItem as its base
 * component. The component is aimed to be the base component for all styled
 * elements in the toolkit. Modules providing additional custom components to
 * UI Toolkit components can also use this component as base, especially if
 * they want to provide styling capabilities.
 *
 * As mentioned, each component is having a style pair in a theme which is implemented
 * in a document named using the component name adding the \e Style word. In this way
 * Button's style is implemented by ButtonStyle.qml document in the theme, and
 * \l Button is loading this style from the theme:
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.3
 *
 * AbstractButton {
 *     id: button
 *     // [...]
 *     style: theme.createStyleComponent("ButtonStyle.qml", button)
 * }
 * \endqml
 * Developers can override the style in two ways, depending on how they want to style
 * the component:
 * \list
 *  \li 1. by overriding the style using an other style component from the theme, or
 *  \li 2. by overriding the style with a custom style component.
 * \endlist
 * But let's see first how the styles are implemented.
 *
 * \section2 Style implementation
 * Style components are meant to provide visual representation of a specific component or
 * even a set of components. However some components allow styles to drive their functionality,
 * and these components typically expect styles to have a well defined API implemented.
 * These APIs are listed in Ubuntu.Components.Styles module, and styles should use these
 * components as base for the style implementation.
 *
 * A good example of such a style is the ListItemStyle. The ListItem drives the style
 * animation through the \l ListItemStyle::animatePanels property, value being false when
 * selection and/or drag panels should be visible when the component loads the style.
 * Also, ListItem informs the style when to execute rebound and whether to overrule
 * swipe coordinates calculated by the ListItem itself or leave it default. On the other
 * hand, the style must inform the component about the position of the drag panel so
 * dragging (reordering of list items in a ListView) hot spot can be detected. A custom
 * style implementation must use the API provided by ListItemStyle, otherwise ListItem
 * will fail to function properly.
 *
 * Beside these, component styles may provide default values for colors, fonts, widths,
 * margins, thicknesses, and most importantly for implicit sizes. All style components are
 * anchor filled into their parent StyledItem, and they are placed behind any content of
 * the styled item (z: -1). Each style component has a \c styledItem context property defined
 * which points to the StyledItem instance instantiating the style.
 *
 * \section2 Overriding the default component style
 * \section3 Override with a different style from the theme
 * Returning back to the ways to override a component's style, overriding by using a different
 * style from the theme can simply be done by calling the theme's \l{Theme::createStyleComponent}
 * {createStyleComponent()} function with the alternative style document name as follows:
 * \qml
 * Button {
 *     id: button
 *     style: theme.createStyleComponent("SquaryButton.qml", button)
 * }
 * \endqml
 * \note This assumes that the \c SquaryButton.qml document is present in the theme.
 * This kind of styling will make sure the style will always be theme specific, however
 * also requires the SquaryButton.qml to be present in all the themes used by the application.
 * \section3 Override with a custom component
 * The other way is to override the style with a local component not present in any theme.
 * This kind of override makes sure the component will use the custom style no matter of the
 * theme used.
 * \qml
 * Button {
 *     id: button
 *     style: Rectangle {
 *         implicitWidth: units.gu(12)
 *         implicitHeight: units.gu(5)
 *         color: styledItem.color
 *         border {
 *             width: units.dp(1)
 *             color: styledItem.strokeColor
 *         }
 *         Label {
 *             text: styledItem.text
 *             font: styledItem.font
 *         }
 *     }
 * }
 * \endqml
 */

/*!
 * \page ubuntu-theming-themes.html
 * \title Themes, theme types, theme structure
 * \nextpage Sub-theming
 *
 * A theme is a collection of style implementations. The style component names are
 * typically built using the component name and the Style word, exceptions being
 * documented per component.
 *
 * In addition to the styles the theme can provide palette values used by the style
 * and components. The palette values are defined in \c Palette.qml file, which must
 * either be derived from \l Palette component or from a parent theme's Palette.
 *
 * There are two types of themes, shared themes and application themes. These themes
 * do not differ in structure but in the way they are exposed. Shared themes are
 * located either under \b QML2_IMPORT_PATH or \b XDG_DATA_DIR. Application themes
 * are located under the application's private folder, therefore they are typically
 * serving the application styling needs, and cannot be shared. Shared themes are also
 * presented as QML extension modules, giving the possibility for application themes
 * to extend them.
 *
 * \note Yet there is no possibility to install shared themes into the system thru
 * app store, only by providing them as part of the system image.
 *
 * The system provides two shared themes, \b Ambiance and \b SuruDark, the latest derived
 * from Ambiance theme. Both themes can be used as base theme in application themes,
 * by importing the modules defining them. If you decide to create a shared theme
 * that can be used also as base for custom or application themes, it is recommended
 * to do the same approach as the system themes do.
 *
 * \section2 Theme structure
 * \image surudark-theme.png
 * The theme structure is similar to a QML extension module structure, and this applies
 * to both shared and application themes. Contains component style documents, palette
 * description document, \c qmldir file and a special file called \c parent_theme. All
 * these files are optional in a theme depending on context.
 *
 * \c parent_theme is a special file which defines the theme the current one is derifed from.
 * The derived theme must be a shared theme and its name must be specified in dotted format.
 * For example SuruDark theme is located under \c{$QML2_IMPORT_PATH/Ubuntu/Components/Themes/SuruDark}
 * folder. This means that the theme name is identified by the \b Ubuntu.Components.Themes.SuruDark
 * dotted format.
 *
 * In addition to the files mentioned, themes can provide components supporting the styling
 * (i.e. components providing common visuals in the style implementations). Style implementations
 * can also provide additional APIs alongside the standard style API. These additional APIs are
 * typically there to configure the style itself, or to turn on/off features provided by styles
 * in derived themes.
 *
 * \section3 Standalone theme
 * A standalone theme is a theme which defines all style documents and theme palette,
 * and it is not derived from any theme. The only standalone theme UI Toolkit provides is
 * the Ambiance theme. Both shared and application themes can be standalone themes, however
 * Applications should make sure they implement all the styles used by the toolkit components
 * used in the application. \c qmldir file presence is mandatory only if the theme is
 * shared.
 *
 * \section3 Derived themes
 * As the name suggests derived themes are themes which use other themes (standalone or derived ones)
 * as base theme. These themes must have the \c parent_theme file to be present and to contain the
 * name of the theme they are derived from. These themes do not have to provide palette configuration
 * as long as they use the derived theme's palette values.
 *
 * Derived themes should only list those style components which overrule the derived style or
 * extend the derived style. The only requirement is to use the same document name as the paren theme
 * is having. For example the SuruDark theme extends the MainViewStyle and therefore declares the
 * MainViewStyle.qml document, with the following content:
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components.Themes.Ambiance 0.1
 *
 * MainViewStyle {
 *     backgroundSource: ""
 * }
 * \endqml
 *
 * The style imports the Ambiance theme module, and extends the Ambiance MainViewStyle
 * component. The same is done in the other style components. However, Palette defines
 * own values, and does not resuse Ambiance palette values.
 * \snippet SuruDark/Palette.qml 0
 *
 * \section2 Application themes
 * Application themes can also be standalone or derived themes. Usually applications
 * need slight differences on certain component styles, colors. These can be configured
 * in multiple ways, depending on the needs of the application. Applications can decide
 * to have their own theme, and override the palette value in the theme, or to use the
 * system themes and override few color values from the theme palette.
 *
 * Let's take an example of an application which changes some palette values of SuruDark
 * theme.
 *
 * First, the application has to define the theme, preferably in a separate folder (e.g.
 * theme). The folder should contain a \c parent_theme file with the content
 * \code
 * Ubuntu.Components.Themes.SuruDark
 * \endcode
 * This will make sure theme engine will look after the style components that are not
 * defined by the application theme inside the parent theme. Remember, parent theme can
 * also have parent theme (in SuruDark case it is) in which case the style components
 * will be looked at in all these themes.
 *
 * As next, the application can define the palette.
 * \snippet customtheme/theme/Palette.qml 0
 * Note that the palette uses the SuruDark palette as base, and changes few colors from it.
 *
 * The application can use its own theme in the following way:
 * \snippet customtheme/main.qml 0
 */

/*!
 * \page ubuntu-theming-subtheming.html
 * \title Sub-theming
 *
 * There can be situations when an application has a design which combines styles from different
 * themes, which would not be possible or would be hard to be combined in a theme. In these
 * situations developers can use different themes in the components and its child components.
 * This is called sub-theming, which was introduced in Ubuntu.Components v1.3.
 * The only thing the application has to do is to define a ThemeSettings instance for the
 * component which is desired to use a different theme.
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Componenst 1.3
 * MainView {
 *     width: units.gu(40)
 *     height: units.gu(71)
 *
 *     applicationName: "subthemed"
 *
 *     // make sure the main theme is Ambiance
 *     theme.name: "Ubuntu.Components.Themes.Ambiance"
 *
 *     Component {
 *         id: dialogComponent
 *         Dialog {
 *             id: dialog
 *             title: "Input dialog"
 *             // make sure the dialog and its children will use SuruDark
 *             theme: ThemeSettings {
 *                 name: "Ubuntu.Components.Themes.SuruDark"
 *             }
 *             TextField {
 *                 placeholderText: "enter text"
 *             }
 *             Button {
 *                 text: "Close"
 *                 onClicked: PopupUtils.close(dialog)
 *             }
 *         }
 *     }
 *
 *     Button {
 *         text: "Open dialog"
 *         onClicked: PopupUtils.open(dialogComponent)
 *     }
 * }
 * \endqml
 *
 * Another use-case is the case when a different palette set is needed in the application.
 * One way to achieve that is to define a custom theme for the application, however
 * that theme must be derived from one particular theme, so the application will be
 * nailed to one given theme. However, if we want to have the same palette values to
 * be used no matter of the component shape, we can override the palette values we want
 * to change, by setting the theme palette to a Palette instance where only the desired
 * palette values are changed. This can be combined with sub-theming, which will make
 * sure that the palette values are applie donly on a certain component sub-tree.
 *
 * The following example makes sure the Dialog and is child components will use a given
 * palette value:
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.3
 * import Ubuntu.Components.Themes 1.0
 *
 * MainView {
 *     width: units.gu(40)
 *     height: units.gu(71)
 *
 *     applicationName: "subthemed"
 *
 *     Component {
 *         id: dialogComponent
 *         Dialog {
 *             id: dialog
 *             title: "Input dialog"
 *             // make sure the dialog and its children will use SuruDark
 *             theme: ThemeSettings {
 *                 name: parentTheme.name
 *                 palette: Palette {
 *                     id: config
 *                     normal {
 *                         foregroundText: UbuntuColors.blue
 *                         overlayText: "#BAFEDC"
 *                     }
 *                     selected {
 *                         fieldText: "brown"
 *                         foregroundText: Qt.rgba(0, 0, 1, 1)
 *                         overlayText: config.normal.overlayText
 *                         foreground: UbuntuColors.green
 *                     }
 *                 }
 *             }
 *             TextField {
 *                 placeholderText: "enter text"
 *             }
 *             Button {
 *                 text: "Close"
 *                 onClicked: PopupUtils.close(dialog)
 *             }
 *         }
 *     }
 *
 *     Column {
 *         spacing: units.gu(1)
 *         Button {
 *             text: "Set Ambiance theme"
 *             onClicked: theme.name = "Ubuntu.Components.Themes.Ambiance"
 *         }
 *         Button {
 *             text: "Set SuruDark theme"
 *             onClicked: theme.name = "Ubuntu.Components.Themes.SuruDark"
 *         }
 *         Button {
 *             text: "Open dialog"
 *             onClicked: PopupUtils.open(dialogComponent)
 *         }
 *     }
 * }
 * \endqml
 * \note Note the way the theme is changed! The first two buttons actually change the
 * name of the theme they inherit, which is the application's theme. This means that
 * the theme will actually be changed on the entire application, not only on the Button
 * itself.
 *
 * The Dialog uses the \l {ThemeSettings::parentTheme}{parentTheme} property to load
 * the same theme as its parent styled item is using, meaning that the Dialog will
 * also load the same theme as the application does, and will change the loaded palette
 * values with th eones defined in the \c config Palette instance, namely the \c
 * foregroundText and \c overlayText of \c normal, as well as \c fieldText, \c foregroundText,
 * \c overlayText and \c foreground on \c selected groups.
 *
 * \section1 That's it
 * By now you should have learned what the styling means, what are the themes, what
 * kind of themes toolkit has, how can you create shared or application themes, where should
 * you store them, how to extend styles, how to use multiple themes in an application
 * and how to set custom palette values runtime. If you still need some guidance, you can
 * post your questions on \b{#ubuntu-app-devel} IRC channel on freenode.
 */
