/*
 * Copyright 2015 Canonical Ltd.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; version 3.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

/*!
 * \page ubuntu-theming.html
 * \title Styling - Introduction
 * \nextpage Component styles, Style API
 *
 * A style defines the visuals of a component. With some exceptions all UI Toolkit
 * components have styles declared. Some styles provide additional logic to the
 * component. These components rely on a well defined API, which must be implemented
 * by the styles. These APIs are provided by the Ubuntu.Components.Styles module.
 * One additional functionality of the style is to provide the implicit size of the
 * component. The theming engine applies the implicit size provided by the style
 * on the component, which can be overruled by the component.
 *
 * With some exceptions, each component's style document name is compound of the
 * component name plus the Style word. In this way the Button component's style is
 * ButtonStyle. These styles are grouped in themes. In addition to styles, themes
 * can also provide custom palette values. There are two themes in Ubuntu, Ambiance
 * and SuruDark themes, Ambiance being the default theme. Both themes are declared
 * in separate modules, in \c Ubuntu.Components.Themes.Ambiance ans well as
 * \c Ubuntu.Components.Themes.SuruDark. Application should define the theme name
 * using this dotted name format.
 *
 * Applications can decide which theme they want to use or they can provide their
 * own themes. Also, applications can use multiple themes or set custom palette values.
 *
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.3
 *
 * MainView {
 *     width: units,gu(40)
 *     height: units.gu(71)
 *
 *     theme.name: "Ubuntu.Components.Themes.SuruDark"
 * }
 * \endqml
 */

/*!
 * \page ubuntu-theming-styles.html
 * \title Component styles, Style API
 * \nextpage Themes, theme types, theme structure
 *
 * \section2 Naming conventions
 * With few exception, each toolkit component is having StyledItem as its base
 * component. The component is aimed to be the base component for all styled
 * elements in the toolkit. Modules providing additional custom components to
 * UI Toolkit components can also use this component as base, especially if
 * they want to provide styling capabilities.
 *
 * As mentioned, each component is having a style pair in a theme which is implemented
 * in a document named using the component name adding the \e Style word. In this way
 * Button's style is implemented by ButtonStyle.qml document in the theme, and
 * \l Button is loading this style from the theme:
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.3
 *
 * AbstractButton {
 *     id: button
 *     // [...]
 *     style: theme.createStyleComponent("ButtonStyle.qml", button)
 * }
 * \endqml
 * Developers can override the style in two ways, depending on how they want to style
 * the component:
 * \list
 *  \li 1. by overriding the style using an other style component from the theme, or
 *  \li 2. by overriding the style with a custom style component.
 * \endlist
 * But let's see first how the styles are implemented.
 *
 * \section2 Style implementation
 * Style components are meant to provide visual representation of a specific component or
 * even a set of components. However some components allow styles to drive their functionality,
 * and these components typically expect styles to have a well defined API implemented.
 * These APIs are listed in Ubuntu.Components.Styles module, and styles should use these
 * components as base for the style implementation.
 *
 * A good example of such a style is the ListItemStyle. The ListItem drives the style
 * animation through the \l ListItemStyle::animatePanels property, value being false when
 * selection and/or drag panels should be visible when the component loads the style.
 * Also, ListItem informs the style when to execute rebound and whether to overrule
 * swipe coordinates calculated by the ListItem itself or leave it default. On the other
 * hand, the style must inform the component about the position of the drag panel so
 * dragging (reordering of list items in a ListView) hot spot can be detected. A custom
 * style implementation must use the API provided by ListItemStyle, otherwise ListItem
 * will fail to function properly.
 *
 * Beside these, component styles may provide default values for colors, fonts, widths,
 * margins, thicknesses, and most importantly for implicit sizes. All style components are
 * anchor filled into their parent StyledItem, and they are placed behind any content of
 * the styled item (z: -1). Each style component has a \c styledItem context property defined
 * which points to the StyledItem instance instantiating the style.
 *
 * \section2 Overriding the default component style
 * \section3 Override with a different style from the theme
 * Returning back to the ways to override a component's style, overriding by using a different
 * style from the theme can simply be done by calling the theme's \l{Theme::createStyleComponent}
 * {createStyleComponent()} function with the alternative style document name as follows:
 * \qml
 * Button {
 *     id: button
 *     style: theme.createStyleComponent("SquaryButton.qml", button)
 * }
 * \endqml
 * \note This assumes that the \c SquaryButton.qml document is present in the theme.
 * This kind of styling will make sure the style will always be theme specific, however
 * also requires the SquaryButton.qml to be present in all the themes used by the application.
 * \section3 Override with a custom component
 * The other way is to override the style with a local component not present in any theme.
 * This kind of override makes sure the component will use the custom style no matter of the
 * theme used.
 * \qml
 * Button {
 *     id: button
 *     style: Rectangle {
 *         implicitWidth: units.gu(12)
 *         implicitHeight: units.gu(5)
 *         color: styledItem.color
 *         border {
 *             width: units.dp(1)
 *             color: styledItem.strokeColor
 *         }
 *         Label {
 *             text: styledItem.text
 *             font: styledItem.font
 *         }
 *     }
 * }
 * \endqml
 */

/*!
 * \page ubuntu-theming-themes.html
 * \title Themes, theme types, theme structure
 * \nextpage Using multiple themes in an application
 *
 * A theme is a collection of style implementations. The style component names are
 * typically built using the component name and the Style word, exceptions being
 * documented per component.
 *
 * In addition to the styles the theme can provide palette values used by the style
 * and components. The palette values are defined in \c Palette.qml file, which must
 * either be derived from \l Palette component or from a parent theme's Palette.
 *
 * There are two types of themes, shared themes and application themes. These themes
 * do not differ in structure but in the way they are exposed. Shared themes are
 * located either under \b QML2_IMPORT_PATH or \b XDG_DATA_DIR. Application themes
 * are located under the application's private folder, therefore they are typically
 * serving the application styling needs, and cannot be shared. Shared themes are also
 * presented as QML extension modules, giving the possibility for application themes
 * to extend them.
 *
 * \note Yet there is no possibility to install shared themes into the system thru
 * app store, only by providing them as part of the system image.
 *
 * The system provides two shared themes, \b Ambiance and \b SuruDark, the latest derived
 * from Ambiance theme. Both themes can be used as base theme in application themes,
 * by importing the modules defining them. If you decide to create a shared theme
 * that can be used also as base for custom or application themes, it is recommended
 * to do the same approach as the system themes do.
 *
 * \section2 Theme structure
 * \image surudark-theme.png
 * The theme structure is similar to a QML extension module structure, and this applies
 * to both shared and application themes. Contains component style documents, palette
 * description document, \c qmldir file and a special file called \c parent_theme. All
 * these files are optional in a theme depending on context.
 *
 * \c parent_theme is a special file which defines the theme the current one is derifed from.
 * The derived theme must be a shared theme and its name must be specified in dotted format.
 * For example SuruDark theme is located under \c{$QML2_IMPORT_PATH/Ubuntu/Components/Themes/SuruDark}
 * folder. This means that the theme name is identified by the \b Ubuntu.Components.Themes.SuruDark
 * dotted format.
 *
 * In addition to the files mentioned, themes can provide components supporting the styling
 * (i.e. components providing common visuals in the style implementations). Style implementations
 * can also provide additional APIs alongside the standard style API. These additional APIs are
 * typically there to configure the style itself, or to turn on/off features provided by styles
 * in derived themes.
 *
 * \section3 Standalone theme
 * A standalone theme is a theme which defines all style documents and theme palette,
 * and it is not derived from any theme. The only standalone theme UI Toolkit provides is
 * the Ambiance theme. Both shared and application themes can be standalone themes, however
 * Applications should make sure they implement all the styles used by the toolkit components
 * used in the application. \c qmldir file presence is mandatory only if the theme is
 * shared.
 *
 * \section3 Derived themes
 * As the name suggests derived themes are themes which use other themes (standalone or derived ones)
 * as base theme. These themes must have the \c parent_theme file to be present and to contain the
 * name of the theme they are derived from. These themes do not have to provide palette configuration
 * as long as they use the derived theme's palette values.
 *
 * Derived themes should only list those style components which overrule the derived style or
 * extend the derived style. The only requirement is to use the same document name as the paren theme
 * is having. For example the SuruDark theme extends the MainViewStyle and therefore declares the
 * MainViewStyle.qml document, with the following content:
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components.Themes.Ambiance 0.1
 *
 * MainViewStyle {
 *     backgroundSource: ""
 * }
 * \endqml
 *
 * The style imports the Ambiance theme module, and extends the Ambiance MainViewStyle
 * component. The same is done in the other style components. However, Palette defines
 * own values, and does not resuse Ambiance palette values.
 *
 * \qml
 * import QtQuick 2.4
 * import Ubuntu.Components 1.2
 * import Ubuntu.Components.Themes 0.1
 *
 * Palette {
 *     normal: PaletteValues {
 *         background: "#221E1C"
 *         backgroundText: "#33F3F3E7"
 *         base: "#19000000"
 *         baseText: "#FFFFFF"
 *         foreground: "#888888"
 *         foregroundText: "#FFFFFF"
 *         overlay: "#F2F2F2"
 *         overlayText: "#888888"
 *         field: "#19000000"
 *         fieldText: "#7F7F7F7F"
 *     }
 *     selected: PaletteValues {
 *         background: "#88D6D6D6"
 *         backgroundText: "#FFFFFF"
 *         selection: Qt.rgba(UbuntuColors.blue.r, UbuntuColors.blue.g, UbuntuColors.blue.b, 0.2)
 *         foreground: UbuntuColors.orange
 *         foregroundText: UbuntuColors.darkGrey
 *         field: "#FFFFFF"
 *         fieldText: "#888888"
 *     }
 * }
 * \endqml
 *
 * \section2 Application themes
 * Application themes can also be standalone or derived themes. Usually applications
 * need slight differences on certain component styles, colors. These can be configured
 * in multiple ways, depending on the needs of the application. Applications can decide
 * to have their own theme, and override the palette value in the theme, or to use the
 * system themes and override few color values from the theme palette.
 *
 * Let's take an example of an application which changes some palette values of SuruDark
 * theme.
 *
 * First, the application has to define the theme, preferably in a separate folder (e.g.
 * theme). The folder should contain a \c parent_theme file with the content
 * \code
 * Ubuntu.Components.Themes.SuruDark
 * \endcode
 * This will make sure theme engine will look after the style components that are not
 * defined by the application theme inside the parent theme. Remember, parent theme can
 * also have parent theme (in SuruDark case it is) in which case the style components
 * will be looked at in all these themes.
 *
 * As next, the application can define the palette.
 * \snippet customtheme/theme/Palette.qml 0
 * Note that the palette uses the SuruDark palette as base, and changes few colors from it.
 *
 * The application can use its own theme in teh following way:
 * \snippet customtheme/main.qml 0
 */

/*!
 * \page ubuntu-theming3.html
 * \title Using multiple themes in an application
 * \nextpage Using custom palette in a component sub-tree
 *
 * -use sub-theming
 * - extend parent theme and override stuff
 */

/*!
 * \page ubuntu-theming4.html
 * \title Using custom palette in a component sub-tree
 * \nextpage Using custom styles
 */

/*!
 * \page ubuntu-theming5.html
 * \title Using custom styles
 */
